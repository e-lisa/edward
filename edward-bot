#! /usr/bin/env python3

"""*********************************************************************
* Edward is free software: you can redistribute it and/or modify       *
* it under the terms of the GNU Affero Public License as published by  *
* the Free Software Foundation, either version 3 of the License, or    *
* (at your option) any later version.                                  *
*                                                                      *
* Edward is distributed in the hope that it will be useful,            *
* but WITHOUT ANY WARRANTY; without even the implied warranty of       *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        *
* GNU Affero Public License for more details.                          *
*                                                                      *
* You should have received a copy of the GNU Affero Public License     *
* along with Edward.  If not, see <http://www.gnu.org/licenses/>.      *
*                                                                      *
* Copyright (C) 2014-2015 Andrew Engelbrecht                (AGPLv3+)  *
* Copyright (C) 2014      Josh Drake                        (AGPLv3+)  *
* Copyright (C) 2014      Lisa Marie Maginnis               (AGPLv3+)  *
*                                                                      *
* Special thanks to Josh Drake for writing the original edward bot! :) *
*                                                                      *
************************************************************************

Code used from:

* http://agpl.fsf.org/emailselfdefense.fsf.org/edward/CURRENT/edward.tar.gz

"""

import sys
import email.parser
import gpgme
import re
import io
import time

def main ():

    handle_args()

    txt = sys.stdin.read()
    msg = email.parser.Parser().parsestr(txt)

    message  = ""
    message += "From: " + msg['From'] + "\n"
    message += "Subject: " + msg['Subject'] + "\n\n"

    message += msg_walk(msg)

    print(message)


def msg_walk (msg):

    body = ""
    for part in msg.walk():

        payload, descript, filename, conttype = get_part_info(part)

        if payload == None:
            continue

        if conttype == 'multipart':
            continue

        if conttype == "application/pgp-encrypted":
            if descript == 'PGP/MIME version identification':
                if payload.strip() != "Version: 1":
                    print(progname + ": Warning: unknown " + descript + ": " \
                            + payload.strip(), file=sys.stderr)
            continue


        if (filename == "encrypted.asc") or (conttype == "pgp/mime"):
            payload_dec = decrypt_payload(payload)
            body += payload_dec

        elif conttype == "text/plain":
            body += payload + "\n"

        else:
            body += payload + "\n"

    return body

def get_part_info (part):

    charset   = part.get_content_charset()
    payload_b = part.get_payload(decode=True)

    filename  = part.get_filename()
    conttype  = part.get_content_type()
    descrip_p = part.get_params(header='content-description')

    if charset == None:
        charset = 'utf-8'

    if payload_b == None:
        payload = None
    else:
        payload = payload_b.decode(charset)

    if descrip_p == None:
        descript = None
    else:
        descript = descrip_p[0][0]


    return payload, descript, filename, conttype


def decrypt_payload (payload):

    blocks = split_message(payload)
    decrypted_tree = decrypt_blocks(blocks)

    if decrypted_tree == None:
        return

    body = ""
    for node in decrypted_tree:
        msg = email.parser.Parser().parsestr(node[0])
        sigs = node[1]

        body += msg_walk(msg)
        for sig in sigs:
            body += format_sig(sig)

    return body


def format_sig (sig):

    fprint = sig.fpr
    fprint_short = re.search("[0-9A-Fa-f]{32}([0-9A-Fa-f]{8})", fprint).groups()[0]

    timestamp = time.localtime(sig.timestamp)
    date = time.strftime("%a %d %b %Y %I:%M:%S %p %Z", timestamp)

    g = gpgme.Context()
    key = g.get_key(fprint)

    # right now i'm just choosing the first user id, even if that id isn't
    # signed by the user yet another is. if a user id is printed, it should
    # at least be one that is signed, and/or correspond to the From:
    # field's email address and full name.

    name = key.uids[0].name
    e_addr = key.uids[0].email
    comment = key.uids[0].comment

    # this section needs some work. signature summary, validity, status,
    # and wrong_key_usage all complicate the picture. their enum/#define
    # values overlap, which makes things more complicated.

    validity = sig.validity
    if validity == gpgme.VALIDITY_ULTIMATE \
            or validity == gpgme.VALIDITY_FULL:
        status = "MAYBE-Good Signature "
    elif validity == gpgme.VALIDITY_MARGINAL:
        status = "MAYBE-Marginal Signature "
    else:
        status = "MAYBE-BAD Signature "


    sig_str  = "Signature Made " + date + " using key ID " + fprint_short + "\n"
    sig_str += status + "from " + name + " (" + comment + ") <" + e_addr + ">"

    return sig_str


def split_message (text):

    pgp_matches = re.search( \
            '(-----BEGIN PGP MESSAGE-----' \
            '.*' \
            '-----END PGP MESSAGE-----)', \
            text, \
            re.DOTALL)

    if pgp_matches == None:
        return None
    else:
        return pgp_matches.groups()


def decrypt_blocks (blocks):

    if blocks == None:
        return None

    message = []
    for block in blocks:
        plain, sigs = decrypt_block(block)

        message = message + [(plain, sigs)]

    return message


def decrypt_block (block):

    block_b = io.BytesIO(block.encode('ASCII'))
    plain_b = io.BytesIO()

    g = gpgme.Context()
    sigs = g.decrypt_verify(block_b, plain_b)

    plain = plain_b.getvalue().decode('ASCII')
    return (plain, sigs)


def handle_args ():
    if __name__ == "__main__":

        global progname
        progname = sys.argv[0]

        if len(sys.argv) > 1:
            print(progname + ": error, this program doesn't " \
                    "need any arguments.", file=sys.stderr)
            exit(1)


main()

